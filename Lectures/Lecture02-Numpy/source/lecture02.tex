\documentclass{beamer}

\usepackage{helvet}
\usepackage{hyperref, graphicx}
\usepackage{amsthm}
\usepackage{etoolbox}

\usetheme{default}
\setbeamertemplate{navigation symbols}{}
\AtBeginSection[ ]
{
\begin{frame}{Outline}
    \tableofcontents[currentsection]
\end{frame}
}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{11} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal - use in headings

% Custom colors
\usepackage{color}
\definecolor{TUGray}{RGB}{101,101,137}
\definecolor{TUBlack}{RGB}{30,0,0}
\definecolor{mygreen}{RGB}{45,111,63}
\definecolor{keywords}{RGB}{205,114,0}
\definecolor{comments}{RGB}{181,51,139}
\definecolor{strings}{RGB}{58,144,81}
\definecolor{numeric}{RGB}{66,110,176}
\definecolor{linos}{rgb}{0.4,0.4,0.4}
\definecolor{links}{rgb}{0,0.4,0.75}

\definecolor{bggray}{RGB}{232, 233, 235}

\usecolortheme[named=mygreen]{structure}
\setbeamercolor{normal text}{fg=TUBlack}\usebeamercolor*{normal text}

\setbeamercolor{codecol}{fg=TUGray!25!black,bg=bggray}

\hypersetup{colorlinks, linkcolor=links, urlcolor=links}

\usepackage[T1]{fontenc}
\usepackage[sfdefault,scaled=.85]{FiraSans}
\usepackage{newtxsf}

\usepackage{listings}

\newtoggle{InString}{}% Keep track of if we are within a string
\togglefalse{InString}% Assume not initally in string

\newcommand\digitstyle{\color{numeric}}
\makeatletter
\newcommand{\ProcessDigit}[1]
{%
  \ifnum\lst@mode=\lst@Pmode\relax%
   {\digitstyle #1}%
  \else
    #1%
  \fi
}
\makeatother

\lstset{literate=%
    {0}{{{\ProcessDigit{0}}}}1
    {1}{{{\ProcessDigit{1}}}}1
    {2}{{{\ProcessDigit{2}}}}1
    {3}{{{\ProcessDigit{3}}}}1
    {4}{{{\ProcessDigit{4}}}}1
    {5}{{{\ProcessDigit{5}}}}1
    {6}{{{\ProcessDigit{6}}}}1
    {7}{{{\ProcessDigit{7}}}}1
    {8}{{{\ProcessDigit{8}}}}1
    {9}{{{\ProcessDigit{9}}}}1
	{<=}{{\(\leq\)}}1
	{>=}{{\(\geq\)}}1,
	% morestring=[b]",
    % morestring=[b]',
    % morecomment=[l]//,
}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttfamily\tiny,
numbers=left,
numberstyle=\tiny\color{linos},
morekeywords={self},              % Add keywords here
keywordstyle=\tiny\color{keywords},
commentstyle=\it\tiny\color{comments},    % Custom highlighting style
stringstyle=\tiny\color{strings},
xleftmargin=18pt,
xrightmargin=4pt,
aboveskip=0pt,
belowskip=0pt,
escapeinside={(*@}{@*)},
frame=l,                         % Any extra options here
showstringspaces=false,
keepspaces=true
}}

% Python environment 
\lstnewenvironment{python}[1][]
{
	\pythonstyle
	\lstset{
	#1
	}
}
{}

% wrap the Python environment
\newenvironment{codeblock}
    {\hfill\begin{beamerboxesrounded}[lower=codecol, width=0.8\textwidth]
    \medskip

    }
    { 
    \end{beamerboxesrounded}\hfill
    }

\theoremstyle{example}
\newtheorem{question}{Question}

\newcommand{\ct}[1]{\lstinline[language=Python]!#1!}
\newcommand{\ttt}[1]{{\small\texttt{#1}}}
\newcommand{\lsitem}[2]{\ttt{{#1}[}\ct{#2}\ttt{]}}

\author{Chris Cornwell}
\date{Jan 17, 2025}
\title{Using Numpy, Linear algebra functionality}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{Intro to NumPy}

%%%%
\begin{frame}[fragile]
\frametitle{Getting started with NumPy}
\begin{itemize}
    \item One of the main packages for scientific computing, a must for machine learning and data science. 
    \item Not built-in {--} must import NumPy into Python session. 
\end{itemize}
%\pause
We will also want to track runtime, so we import the package \ttt{time}.

%\pause 
\begin{codeblock}

\begin{python}
    import numpy as np
    import time
\end{python}

\end{codeblock}

\begin{itemize}
    \item[] Create a shortcut, \ttt{np}, for NumPy. This is a common convention.
\end{itemize}

%\pause
\begin{itemize}
	\item Depending on how you are interacting with Python, may have to \emph{install} the \ttt{numpy} package before the first use. Open a command terminal (\ttt{Ctrl+`}, in VSCode on Windows) and type the appropriate command below.
\end{itemize}
\begin{itemize}
	\item[] \ttt{py -m pip install numpy} (Windows)
	\item[] \ttt{python3 -m pip install numpy} (macOS)
    \item[] \ttt{sudo pip install numpy} (Linux based)
\end{itemize}
When installing other packages, replace \ttt{numpy} with the package name. After install, the import commands above should run without error.

\end{frame}

\section{NumPy arrays}
%%%%
\begin{frame}[fragile]
\frametitle{Basic NumPy arrays}
The main type of object in NumPy is the \ttt{ndarray} (n-dimensional array), which is constructed from a list using the command 
\begin{center}\ttt{np.array(the}\ct{_}\ttt{list)}.\end{center}

\vspace*{12pt}
%\pause
If items in \ttt{the}\ct{_}\ttt{list} are of numeric type, then think of the resulting \ttt{ndarray} as like a vector. Operations on NumPy arrays work like vectors in linear algebra.
\vspace*{12pt}

%\pause
Example:

\begin{codeblock}

\begin{python}
v = np.array([-1, 1, 1])
w = np.array([0.5, 0, 1.1])
# print the (vector) sum: [-0.5  1.   2.1]
print(v + w)
# prints [1.0, 0.0, 2.2]
print(2*w)
\end{python}

\end{codeblock}

\end{frame}

%%%%
\begin{frame}[fragile]
\frametitle{More than {\ttm 1d}}
A NumPy array from a list containing numeric types makes a vector {--} also known as a 1-\emph{dimensional array} (Python language), or a \emph{tensor of order} 1 (mathematics). 

%\pause
A 2-dimensional array, or tensor of order 2, is like a matrix. You construct it with \ttt{np.array()} from a list of lists {--} each of the same length.

\begin{codeblock}

\begin{python}[numbers=none]
A = np.array([[1, 2, 3], [4, 5, 6]])
\end{python}

\end{codeblock}

\begin{itemize}
    \item[] Each ``inside list'' is a row. The array \ttt{A} is a $2\times 3$ matrix.
\end{itemize}

%\pause
Every array in NumPy has an attribute \ttt{shape}. 
\begin{itemize}
    \item Previous slide: \ttt{v = np.array([-1,1,1])} has \ttt{v.shape = (3,)}. 
    \item The matrix \ttt{A}: \ttt{A.shape} is equal to \ct{(2, 3)}.
\end{itemize}
\end{frame}

%%%%
\begin{frame}[fragile]
\frametitle{Operations on arrays}

Multiplying two arrays: most recent version of Python uses the \ttt{@} symbol.\footnote{In older versions, matrix multiplication is \ttt{np.matmul()} and dot product is \ttt{np.dot()}.} 

When the arrays are both matrices, it computes their matrix product; when one is a vector, it computes the matrix-vector product; when both are vectors, it computes the dot product.

%You can also use the function \ttt{np.dot()} for these computations. However, the \ttt{@} symbol is needed to compute products of higher order tensors.\footnote{\ttt{np.dot()} on higher tensors would compute simply the matrix product in the last two dimensions.}

%\pause
For example, say that \ttt{A} is the matrix $\begin{bmatrix}1 & 2 & 3 \\ 4 & 5 & 6\end{bmatrix}$ from before, \ttt{v} is the vector $(-1, 1, 1)$, and let \ttt{B} and \ttt{u} be the matrix and vector defined in the code below.

\vspace*{12pt}
\begin{codeblock}

\begin{python}
B = np.array([[1, 0], [1, -1], [1, 1]])
u = np.array([1, 1, 0])

(A @ B, A @ v, v @ u)
\end{python}

\end{codeblock}
%\pause
\begin{itemize}
    \item Output is the ordered triple 
    \item[] \qquad \ct{( array([[6, 1], [15, 1]]), array([4, 7]), 0 )}.
\end{itemize}
\vspace*{12pt}

\end{frame}

%%%%
\begin{frame}
\frametitle{Indexing and slicing arrays}
Items in 1d array are accessed the same way as in a list (e.g., \ttt{v}\ct{[0]} is the first item, at index 0).  For a 2d array, say the matrix \ttt{A}, we can access the item in the row \ct{i} and column \ct{j} by \ttt{A}\ct{[i, j]}.

\vspace*{12pt}
%\pause
Like lists, can also use slicing with arrays. Examples:
\begin{enumerate}
    \item To get first column of the matrix \ttt{A}, write \ttt{A}\ct{[: , 0]}.\footnote{Recall the use of the colon from before. It functions the same way here.}
    %\pause 
    \item To get top-right $2\times 2$ submatrix of a matrix \ttt{M}, then use \ttt{M}\ct{[:2, -2:]}.
\end{enumerate}

% \begin{codeblock}

% \begin{python}
% \end{python}

% \end{codeblock}

%\pause
A row of \ttt{A} is easier {--} row \ct{i} would be \ttt{A}\ct{[i]}.\footnote{Could, if you want, use slicing: \ttt{A}\ct{[i, :]}.}

%\pause
If \ttt{A} is a 2d array, its transpose is \ttt{A.T} (providing yet another alternative for accessing a column).
\end{frame}

\section{Linear algebra}

%%%%
\begin{frame}[fragile]
\frametitle{Constructing special matrices}
Some types of matrices are used a lot; would be cumbersome to always write the row lists ourselves (e.g., in a $100\times100$ matrix).
    
    %pause
    \begin{itemize}
        \item[] \textbf{Zero matrix}: The command \ttt{np.zeros((m, n))} constructs an $m\times n$ matrix with all entries equal to zero.
        %\pause
        \item[] \textbf{Diagonal matrix}: If \ttt{d} is a 1d array of length $n$, the command \ttt{np.diag(d)} constructs an $n\times n$ diagonal matrix which has \ttt{d} as its diagonal entries.
        %\pause
        \item[] \textbf{Identity matrix}: The command \ttt{np.eye(n)} constructs the $n\times n$ identity matrix.
    \end{itemize}
    
%pause
\textbf{Extracting part of matrix:} May want to get part of a matrix. To get a submatrix from consecutive rows and columns, use slicing. %\pause
Also, here are functions that return part of the matrix (other entries being set to \ttt{0}).%\footnote{Can use a \emph{method} for last one: \ttt{A.diagonal()} returns the same as \ttt{np.diag(A)}.} 

\begin{codeblock}

\begin{python}
# return lower triangular part (at or below the diagonal)
np.tril(A)
# return upper triangular part (at or above the diagonal)
np.triu(A)
# return the diagonal of A
np.diag(A)
\end{python}

\end{codeblock}
\end{frame}

%%%%
\begin{frame}
\frametitle{Using NumPy for linear algebra}
In addition to the product operations on arrays, NumPy has a library (\ttt{linalg}) with many functions for linear algebra. 

%\pause
Examples: 
\begin{enumerate}
    \item If $M$ is a square matrix, can compute $\det(M)$ with the command \ttt{np.linalg.det(M)}.
    %\pause
    \item When $M$ is invertible, can compute $M^{-1}$ with the command \ttt{np.linalg.inv(M)}.
    %\pause
    \item If $M$ is a square matrix, can compute eigenvalues and eigenvectors with \ttt{np.linalg.eig(M)}. 
\end{enumerate}

%\pause
There are many other linear algebra functions. Some are only implemented for square matrices (and perhaps only invertible ones), even though it would make sense to have them work more generally {--} for example, \ttt{np.solve(A, b)} only solves the system $A\mathbf{x} = b$ if \ttt{A} is a square invertible matrix.
\end{frame}

%%%%
\begin{frame}[fragile]
\frametitle{Solving a linear system \& Errors}
To solve $A\mathbf{x} = \mathbf{b}$, with a square invertible matrix \ttt{A} and vector \ttt{b} of the right size, you can use \ttt{np.linalg.solve(A, b)}.

%\pause
What happens when \ttt{A} is not square? Execute the following code in Python.

\begin{codeblock}

\begin{python}
    A = np.array([[1, 2, 3], [1, 4, -1]])
    b = np.array([1, -5])
    # system has solution x = [0, -1, 1]
    # but next line raises an error
    x = np.linalg.solve(A, b)
\end{python}

\end{codeblock}

%\pause
A message is generated about the error. It gives you helpful information, if it can. In this case, it is a \ttt{LinAlgError} with the message \ttt{Last 2 dimensions of the array must be square}.

%\pause
Spend time trying to use error messages to understand issues in your code. Also, have healthy skepticism about AI assistants. They hallucinate; error messages don't.\footnote{While writing this slide, Github Copilot suggested I write that it would be a \ttt{ValueError} from \emph{mismatched dimensions}: rows of \ttt{A} being size \ttt{(3,)} and the vector \ttt{b} being size \ttt{(2,)}.}
\end{frame}

\section{Broadcasting and efficient operations}
%%%%
\begin{frame}[fragile]
\frametitle{Broadcasting, universal functions}
Say that you have a 1d array and you want to make array with square root the entries. 
\begin{itemize}
    \item[] First thought: use a loop, taking square root (and assigning) as you go through items in the array.
\end{itemize}

NumPy has an efficient way to handle it, called \emph{broadcasting}. If \ttt{v} is your array, then you can simply type 

\begin{codeblock}

\begin{python}[numbers=none]
sqrt_v = np.sqrt(v)
\end{python}

\end{codeblock}

\begin{itemize}
    \item[] The function \ttt{np.sqrt()} takes the square root of each entry in \ttt{v}; you don't need to write the for loop.\footnote{Technically, there's a for loop in the background, but it happens in C and works much faster.}
\end{itemize}
Functions that work on arrays this way are quite common in NumPy. They are called {\ttb ufuncs} (universal functions).

%\pause
Other examples of ufuncs in NumPy: 
    \begin{itemize}
        \item[] \ttt{np.abs()}, \ttt{np.sum()}, \ttt{np.maximum()}, \ttt{np.minimum()}, \ttt{np.exp()}, \ttt{np.log()}.
    \end{itemize}
\end{frame}

\begin{frame}
\frametitle{More on broadcasting}
Many basic operations with NumPy arrays use broadcasting. Here are a few examples with an array \ttt{v}.
\begin{enumerate}
    \item To add the same scalar, say \ct{3}, to every array entry: type \ttt{v+3}.
    \item To multiply every entry by \ct{3}: type \ttt{3*v}.
    %\pause
    \item To square every entry of an array: type \ttt{v**2}.
    \item To multiply \ttt{v} by another array \ttt{w}, entry-wise\footnote{In mathematics, this product on vectors is called the Hadamard product.}: type \ttt{v*w}.
\end{enumerate}

%\pause
Everything mentioned here works just as well on matrices (2d arrays), and generally on any \ttt{n}d array (higher order tensors).

\vspace*{12pt}
%\pause
Exercise. \newline
Write out code that uses broadcasting to create a $100\times 100$ matrix where all non-diagonal entries are $-1$ and all diagonal entries are $2$.
\end{frame}

%%%%
\begin{frame}[fragile]
\frametitle{Experiment with runtime for universal function}
To check the efficiency of broadcasting, use the \ttt{time} package. Beforehand, make sure that you imported both \ttt{numpy} and \ttt{time} (see slide in first section).

%\pause
Something simple: from a large identity matrix, we will get the exponential of the matrix (apply the function $e^x$ to every entry).

%\pause
First, we use a \ttt{for} loop. Run the code below in your Jupyter notebook.

\begin{codeblock}

\begin{python}
id_matrix = np.eye(1000)
exp_matrix = np.zeros((1000, 1000))
start = time.time()
for i in range(1000):
    for j in range(1000):
        exp_matrix[i,j] = np.exp(id_matrix[i,j])
end = time.time()
print(f"Seconds taken: {end-start}.")
\end{python}

\end{codeblock}

\vspace*{12pt}
%\pause
\begin{itemize}
    \item[] The output gives the number of seconds to run the computation. The exact time will vary based on your computer. Mine took around 0.55 seconds.
\end{itemize}
\end{frame}

%%%%
\begin{frame}[fragile]
\frametitle{Experiment with runtime for universal function}
Now, we will use broadcasting to compute the exponential of the identity matrix.

%\pause
Run the following code in your Jupyter notebook.

\begin{codeblock}

\begin{python}
id_matrix = np.eye(1000)
exp_matrix = np.zeros((1000, 1000))
start = time.time()
exp_matrix = np.exp(id_matrix)
end = time.time()
print(f"Seconds taken: {end-start}.")
\end{python}

\end{codeblock}

\vspace*{12pt}
%\pause
\begin{itemize}
    \item[] Again, the output is the number of seconds of runtime. For this approach with \ttt{np.exp()}, my computer took around 0.0045 seconds. That is over 100 times faster than writing the loop!
\end{itemize}
\end{frame}

\end{document}